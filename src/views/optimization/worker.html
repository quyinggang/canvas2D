<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Worker + OffscreenCanvas</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
      #canvas1, #canvas2 {
        width: 600px;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <canvas id="canvas1" width="1200" height="800"></canvas>
      <canvas id="canvas2" width="1200" height="800"></canvas>
    </div>
    <script>
      // Offscreen创建方式一：将控制权交给worker内部处理，绘制的内容会自动同步在canvas上显示，无需手动同步
      const canvas1 = document.getElementById("canvas1");
      if (!!canvas1.transferControlToOffscreen) {
        const offscreen = canvas1.transferControlToOffscreen();
        const worker = new Worker("./worker.js");
        worker.postMessage({ canvas: offscreen }, [offscreen]);
      }

      // Offscreen创建方式二：使用OffscreenCanvas构造函数创建，需要将其主动同步到canvas上显示
      const canvas2 = document.getElementById("canvas2");
      if (!!canvas1.transferControlToOffscreen) {
        const ctx = canvas2.getContext('2d')
        const worker = new Worker('./worker.js')
        worker.postMessage({ type: 'init', size: { width: 1200, height: 800 }})
        worker.onmessage = (evt) => {
          ctx.drawImage(evt.data.imageBitmap, 0, 0)
        }

        // 主线程创建其他图形
        ctx.save()
        ctx.fillStyle = 'red';
        ctx.beginPath()
        ctx.rect(100, 100, 200, 200)
        ctx.fill()
        ctx.closePath()
        ctx.restore()
      }
    </script>
  </body>
</html>
